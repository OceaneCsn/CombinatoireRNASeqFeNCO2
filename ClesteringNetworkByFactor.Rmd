---
title: "Analyse d'expression différentielle mutli-facteurs : Fer, Azote et CO2"
subtitle: "Clustering et réseau pour les gènes répondant à chaque facteur"
author: "Océane Cassan"
date: "10/25/2019"
output: 
  rmdformats::material:
    fig_width: 12
    highlight: kate
    includes:
        after_body: footer.html
---

On cherche à étudier l'effet de trois facteurs sur le transcriptome des racines d'Arabidopsis thaliana et de la micro Tomate.

```{r knitr_init, echo=FALSE, cache=FALSE}
library(knitr, warn.conflicts = F, quietly = T)
library(rmdformats, warn.conflicts = F, quietly = T)

## Global options
options(max.print="75")
opts_chunk$set(cache=FALSE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE,
               fig.align = "center")
opts_knit$set(width=75)
#setwd("~/Documents/CombinatoireFeNCO2/Combinatoire/")
library(gridExtra)
library(reshape2)
suppressMessages(library(gridExtra, warn.conflicts = F, quietly = T))
suppressMessages(library(stringr, warn.conflicts = F, quietly = T))
suppressMessages(library(ggpubr, warn.conflicts = F, quietly = T))
suppressMessages(library(ggplot2, warn.conflicts = F, quietly = T))
suppressMessages(library(clusterProfiler, warn.conflicts = F, quietly = T))
suppressMessages(library(enrichplot, warn.conflicts = F, quietly = T))
suppressMessages(library(ggpubr, warn.conflicts = F, quietly = T))
suppressMessages(library(psych, warn.conflicts = F, quietly = T))
suppressMessages(library(igraph, warn.conflicts = F, quietly = T))
#self written functions for differential expression
source("./DEFunctions.R")

specie = "At"
```

# CO2

## Clustering

```{r cluster}
load(paste0("./GenesCO2_",specie,".RData"))

#quantification file
data <- read.csv("quantifFiles/QuantifGenes.csv", h = T, sep = ',')
rownames(data) <- data$Gene
genes = which(!(grepl("__", rownames(data))))
not_quant = data[which((grepl("__", rownames(data)))),]
data = data[genes,grepl('R', colnames(data))]

keep <- rowSums(data) >= 10
data <- data[keep,]
group <- sapply(colnames(data), getLabel, with.rep = F)
colnames(data) <- sapply(colnames(data), getLabel)

specie = "At"
clusteredGenes <- clustering(sharedBy3, data)

a <- OntologyProfile(sharedBy3)
a$cluster <- clusteredGenes[a$ensembl_gene_id]

entrezID <- list()
nb_clust = max(clusteredGenes)
for (clust in seq(1:nb_clust)) {
    # print(entrez[entrez$cluster == clust,]$ensembl_transcript_id)
    entrezID[[length(entrezID) + 1]] <- na.omit(a[a$cluster == clust, ]$entrezgene_id)
}
names(entrezID) <- as.character(seq(1:nb_clust))

ck <- compareCluster(geneCluster = entrezID, fun = "enrichGO", OrgDb = org.At.tair.db, ont = "BP", pAdjustMethod = "BH", 
    pvalueCutoff = 0.01, qvalueCutoff = 0.05)

clusterProfiler::dotplot(ck, x = ~Cluster)


# On essaie un autre clustering avec lka librarie MPLN
#mpln (dataset = as.matrix(data[sharedBy3,]))
#beaucoup trop long, même mutlithreadé, c'est n'imp
```

Model-Based Clustering Using MPLN (Parallelized)
Description
Performs clustering using mixtures of multivariate Poisson-log normal (MPLN) distribution and model selection using AIC, AIC3, BIC and ICL. Since each component/cluster size (G) is independent from another, all Gs in the range to be tested have been parallelized to run on a seperate core using the parallel R package.



## Visualisation en ACP

```{r acp}

ACP(data[sharedBy3,], clusteredGenes)

```

## Réseau 

```{r net}

load("./normalized.count_At.RData")
log.data <- log2(normalized.count[sharedBy3,]+1)


Norm.interest.corr<-corr.test(t(log.data), method="pearson", ci=F)
Norm.interest.corr$p[lower.tri( Norm.interest.corr$p,diag=-TRUE)]=NA
Pval.adj<- as.data.frame(as.table(Norm.interest.corr$p))
Norm.interest.corr$r[lower.tri(Norm.interest.corr$r,diag=TRUE)]=NA
Correlation<-  as.data.frame(as.table(Norm.interest.corr$r))
Cor.table<- na.exclude(cbind( Correlation, Pval.adj))[,c(1,2,3,6)]
colnames(Cor.table)<- c("gene1","gene2","cor","p.adj")
Cor.table.filt<- Cor.table [(abs(Cor.table[,3])>0.9 & Cor.table[,4]<0.01 ),]

g<-  graph.data.frame(  Cor.table.filt[,1:2],  directed=-FALSE)
V(g)$color <- clusteredGenes[V(g)]
degree<- degree(g)
hist(degree, breaks = 30)
betweenness<- betweenness(g)
hist(betweenness)
Node_nw_st<- data.frame( degree, betweenness)
plot.igraph(g, vertex.size = 5, vertex.label.cex = 0.3, color = clusteredGenes) 

library(d3r)

data_json <- d3_igraph(g)
write(data_json, "data.json")


write.table(Cor.table.filt, "GraphCO2.txt", sep="\t", row.names=F, quote=F)

Rank_stat <- rowMeans(cbind(rank(Node_nw_st[,1]), rank(Node_nw_st[,2])))
Node_nw_st <- cbind(Node_nw_st, Rank_stat)
write.table(Node_nw_st,file="StatsCO2.txt", sep="\t", col.names = NA, quote=F)
```

# Nitrate

```{r nitrate}
load("GenesNitrate_At.RData")
clusteredGenes <- clustering(sharedBy3, data)
ACP(data[sharedBy3,], clusteredGenes)

log.data <- log2(normalized.count[sharedBy3,]+1)


Norm.interest.corr<-corr.test(t(log.data), method="pearson", ci=F)
Norm.interest.corr$p[lower.tri( Norm.interest.corr$p,diag=-TRUE)]=NA
Pval.adj<- as.data.frame(as.table(Norm.interest.corr$p))
Norm.interest.corr$r[lower.tri(Norm.interest.corr$r,diag=TRUE)]=NA
Correlation<-  as.data.frame(as.table(Norm.interest.corr$r))
Cor.table<- na.exclude(cbind( Correlation, Pval.adj))[,c(1,2,3,6)]
colnames(Cor.table)<- c("gene1","gene2","cor","p.adj")
Cor.table.filt<- Cor.table [(abs(Cor.table[,3])>0.9 & Cor.table[,4]<0.01 ),]

g<-  graph.data.frame(  Cor.table.filt[,1:2],  directed=-FALSE)
V(g)$color <- clusteredGenes[V(g)]
degree<- degree(g)
hist(degree, breaks = 30)
betweenness<- betweenness(g)
hist(betweenness)
Node_nw_st<- data.frame( degree, betweenness)
plot.igraph(g, vertex.size = 5, vertex.label.cex = 0.01, color = clusteredGenes) 


a <- OntologyProfile(sharedBy3)
a$cluster <- clusteredGenes[a$ensembl_gene_id]

entrezID <- list()
nb_clust = max(clusteredGenes)
for (clust in seq(1:nb_clust)) {
    # print(entrez[entrez$cluster == clust,]$ensembl_transcript_id)
    entrezID[[length(entrezID) + 1]] <- na.omit(a[a$cluster == clust, ]$entrezgene_id)
}
names(entrezID) <- as.character(seq(1:nb_clust))

ck <- compareCluster(geneCluster = entrezID, fun = "enrichGO", OrgDb = org.At.tair.db, ont = "BP", pAdjustMethod = "BH", 
    pvalueCutoff = 0.01, qvalueCutoff = 0.05)

clusterProfiler::dotplot(ck, x = ~Cluster)
```

# Iron

```{r iron}
load("GenesIron_At.RData")
clusteredGenes <- clustering(sharedBy3, data)
ACP(data[sharedBy3,], clusteredGenes)

log.data <- log2(normalized.count[sharedBy3,]+1)


Norm.interest.corr<-corr.test(t(log.data), method="pearson", ci=F)
Norm.interest.corr$p[lower.tri( Norm.interest.corr$p,diag=-TRUE)]=NA
Pval.adj<- as.data.frame(as.table(Norm.interest.corr$p))
Norm.interest.corr$r[lower.tri(Norm.interest.corr$r,diag=TRUE)]=NA
Correlation<-  as.data.frame(as.table(Norm.interest.corr$r))
Cor.table<- na.exclude(cbind( Correlation, Pval.adj))[,c(1,2,3,6)]
colnames(Cor.table)<- c("gene1","gene2","cor","p.adj")
Cor.table.filt<- Cor.table [(abs(Cor.table[,3])>0.9 & Cor.table[,4]<0.01 ),]

g<-  graph.data.frame(  Cor.table.filt[,1:2],  directed=-FALSE)
V(g)$color <- clusteredGenes[V(g)]
degree<- degree(g)
hist(degree, breaks = 30)
betweenness<- betweenness(g)
hist(betweenness)
Node_nw_st<- data.frame( degree, betweenness)
plot.igraph(g, vertex.size = 5, vertex.label.cex = 0.01, color = clusteredGenes) 

a <- OntologyProfile(sharedBy3)
a$cluster <- clusteredGenes[a$ensembl_gene_id]

entrezID <- list()
nb_clust = max(clusteredGenes)
for (clust in seq(1:nb_clust)) {
    # print(entrez[entrez$cluster == clust,]$ensembl_transcript_id)
    entrezID[[length(entrezID) + 1]] <- na.omit(a[a$cluster == clust, ]$entrezgene_id)
}
names(entrezID) <- as.character(seq(1:nb_clust))

ck <- compareCluster(geneCluster = entrezID, fun = "enrichGO", OrgDb = org.At.tair.db, ont = "BP", pAdjustMethod = "BH", 
    pvalueCutoff = 0.01, qvalueCutoff = 0.05)

clusterProfiler::dotplot(ck, x = ~Cluster)
```
